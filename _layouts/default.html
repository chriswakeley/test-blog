<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{% if page.title %}{{ page.title }} · {% endif %}{{ site.title }}</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@400;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="{{ '/assets/css/tailwind.css' | relative_url }}">
  <link rel="stylesheet" href="{{ '/assets/css/main.css' | relative_url }}">
  {% seo %}
  <link rel="icon" type="image/png" href="{{ '/assets/images/stressburner-faviconlogo.png' | relative_url }}">
  <link rel="apple-touch-icon" href="{{ '/assets/images/stressburner-faviconlogo.png' | relative_url }}">
  <meta name="theme-color" content="#9A0C0C">
</head>
<body class="page-{{ page.title | downcase | replace: ' ', '-' }}">
  <header class="sb-header">
    <div class="container header-inner">
      <a class="brand" href="{{ '/' | relative_url }}" aria-label="{{ site.title }}">
        <img src="{{ '/assets/images/logo-large.png' | relative_url }}" alt="Stress Burner lotus logo" />
      </a>
      <button class="nav-toggle" aria-expanded="false" aria-controls="primary-nav">☰</button>
      <nav id="primary-nav" class="nav">
        {% for item in site.nav %}
          {% if item.external %}
            <a href="{{ item.external }}" class="nav-link" target="_blank" rel="noopener">{{ item.title }}</a>
          {% else %}
            <a href="{{ item.url | relative_url }}" class="nav-link{% if page.url == item.url %} active{% endif %}">{{ item.title }}</a>
          {% endif %}
        {% endfor %}
      </nav>
    </div>
  </header>

  <main>
    {{ content }}
  </main>

  <footer class="sb-footer">
    <div class="container">
      <p>© {{ site.time | date: '%Y' }} {{ site.title }} · <a href="{{ '/contact/' | relative_url }}">Contact</a></p>
    </div>
  </footer>
  <script>
    (function(){
      const btn = document.querySelector('.nav-toggle');
      const nav = document.getElementById('primary-nav');
      if(btn && nav){
        btn.addEventListener('click', () => {
          const open = btn.getAttribute('aria-expanded') === 'true';
          btn.setAttribute('aria-expanded', String(!open));
          nav.classList.toggle('open', !open);
        });
      }
      // Progressive header blur/background on scroll (home page only)
      const header = document.querySelector('.sb-header');
      if (header) {
        let ticking = false;
        const max = 180; // px of scroll to reach full effect
        const update = () => {
          const y = window.scrollY || window.pageYOffset || 0;
          const t = Math.max(0, Math.min(1, y / max));
          // Variables (some legacy), plus shadow intensity
          header.style.setProperty('--header-bg', (0.75 * t).toFixed(3));
          header.style.setProperty('--header-blur', (8 * t).toFixed(2) + 'px');
          header.style.setProperty('--header-border', (0.06 * t).toFixed(3));
          header.style.setProperty('--header-shadow', t.toFixed(3));
          ticking = false;
        };
        update();
        window.addEventListener('scroll', () => {
          if (!ticking) {
            ticking = true;
            requestAnimationFrame(update);
          }
        }, { passive: true });
      }

      // Smooth pressed animation for buttons (adds/removes .is-pressed)
      try {
        const pressables = document.querySelectorAll('.btn');
        const add = (el) => el.classList.add('is-pressed');
        const remove = (el) => el.classList.remove('is-pressed');
        pressables.forEach(btn => {
          btn.addEventListener('pointerdown', () => add(btn));
          btn.addEventListener('pointerup', () => remove(btn));
          btn.addEventListener('pointerleave', () => remove(btn));
          btn.addEventListener('pointercancel', () => remove(btn));
          btn.addEventListener('blur', () => remove(btn));
          btn.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') add(btn); });
          btn.addEventListener('keyup', () => remove(btn));
        });
      } catch {}

      // Inject flowers SVG inline into hero so we can style stroke/fill via CSS (no edits to the SVG file itself)
      const heroContainer = document.querySelector('.hero .container');
      if (heroContainer) {
        // Ensure background layers exist for animation/parallax
        const ensureLayer = (cls) => {
          let el = heroContainer.querySelector(`.${cls}`);
          if (!el) {
            el = document.createElement('div');
            el.className = `bg-layer ${cls}`;
            heroContainer.insertBefore(el, heroContainer.firstChild);
          }
          return el;
        };
        const bg0 = ensureLayer('bg-0');
        const bg1 = ensureLayer('bg-1');

        // Parallax setup (outside fetch so it always runs)
        const heroSection = document.querySelector('.hero');
        const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        let flowers = null;
        let ticking2 = false;
        // Device tilt state (mobile additive parallax)
        let tiltY = 0;          // smoothed [-1, 1]
        let targetTiltY = 0;    // instantaneous [-1, 1]
        let tiltEnabled = false;

        const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
        const px = (n) => `${Math.round(n)}px`;
        const updateParallax = () => {
          if (!heroSection || prefersReduced) { ticking2 = false; return; }
          const rect = heroSection.getBoundingClientRect();
          const h = rect.height || 1;
          // Progress based on page scroll so it starts as soon as the user scrolls even a little
          const y = window.scrollY || window.pageYOffset || 0;
          const t = clamp(y / h, 0, 1);
          // Scale motion
          const isMobile = (window.innerWidth || 0) <= 900;
          const scale = isMobile ? 1.0 : 1.3;
          // Downward movement: flowers (least), foreground (more), background 0 (most)
          const mf = 60 * scale;    // flowers overlay (smallest)
          const m1 = 250 * scale;   // foreground (middle)
          const m0 = 340 * scale;   // far background (largest)
          // Smooth tilt easing
          tiltY += (targetTiltY - tiltY) * 0.12;
          // Convert tilt to additive px motion on Y (mobile only)
          const tyFactor = isMobile ? 1 : 0; // only enable on mobile widths
          const add0 = tyFactor * (tiltY * 50); // strongest on far background
          const add1 = tyFactor * (tiltY * 32);
          const addF = tyFactor * (tiltY * 14);
          if (bg0) bg0.style.setProperty('--scroll-y', px((t * m0) + add0));
          if (bg1) bg1.style.setProperty('--scroll-y', px((t * m1) + add1));
          if (flowers) flowers.style.setProperty('--scroll-y', px((t * mf) + addF));
          ticking2 = false;
        };
        const onScroll = () => { if (!ticking2) { ticking2 = true; requestAnimationFrame(updateParallax); } };
        window.addEventListener('scroll', onScroll, { passive: true });
        window.addEventListener('resize', () => { requestAnimationFrame(updateParallax); }, { passive: true });
        updateParallax();

        // Device orientation activation (with iOS permission flow)
        const tryEnableTilt = async () => {
          if (tiltEnabled || prefersReduced) return;
          const isMobile = (window.innerWidth || 0) <= 900;
          if (!isMobile) return;
          try {
            if (typeof window.DeviceOrientationEvent !== 'undefined' && typeof window.DeviceOrientationEvent.requestPermission === 'function') {
              // iOS requires a user gesture
              const res = await window.DeviceOrientationEvent.requestPermission();
              if (res !== 'granted') return;
            }
            const onOrient = (e) => {
              // beta: front-back tilt, clamp to [-30, 30] degrees
              const beta = typeof e.beta === 'number' ? e.beta : 0;
              const norm = clamp(beta / 30, -1, 1);
              targetTiltY = norm;
              if (!ticking2) { ticking2 = true; requestAnimationFrame(updateParallax); }
            };
            window.addEventListener('deviceorientation', onOrient, true);
            tiltEnabled = true;
          } catch { /* ignore permission errors */ }
        };
        // For Android and browsers that don't need explicit permission, try enabling immediately
        if (typeof window.DeviceOrientationEvent !== 'undefined' && typeof window.DeviceOrientationEvent.requestPermission !== 'function') {
          tryEnableTilt();
        }
        // Fallback: enable tilt after first user interaction (for iOS)
        const onceActivate = () => { tryEnableTilt(); window.removeEventListener('touchend', onceActivate); window.removeEventListener('click', onceActivate); };
        window.addEventListener('touchend', onceActivate, { passive: true, once: true });
        window.addEventListener('click', onceActivate, { once: true });

        // Fetch and inline the flowers SVG (so CSS can style it)
        const svgUrl = '{{ "/assets/images/hero-background-layer-flowers.svg" | relative_url }}';
        try {
          fetch(svgUrl, { cache: 'force-cache' })
            .then(r => r.ok ? r.text() : Promise.reject(r.status))
            .then(svgText => {
              const wrap = document.createElement('div');
              wrap.className = 'flowers-layer';
              wrap.innerHTML = svgText;
              // Normalize dimensions and aspect ratio handling so CSS centering works consistently
              const svgEl = wrap.querySelector('svg');
              if (svgEl) {
                svgEl.removeAttribute('width');
                svgEl.removeAttribute('height');
                // Use 'slice' to mimic CSS background-size: cover behavior within the hero container
                svgEl.setAttribute('preserveAspectRatio', 'xMidYMid slice');
              }
              heroContainer.appendChild(wrap);
              flowers = wrap;
              // Apply an initial parallax position now that flowers exist
              requestAnimationFrame(updateParallax);
            })
            .catch(() => { /* no-op if SVG fails to load */ });
        } catch { /* ignore */ }
      }
    })();
  </script>
</body>
</html>