<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{% if page.title %}{{ page.title }} · {% endif %}{{ site.title }}</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="{{ '/assets/css/tailwind.css' | relative_url }}">
  <link rel="stylesheet" href="{{ '/assets/css/main.css' | relative_url }}">
  {% seo %}
  <link rel="icon" type="image/png" href="{{ '/assets/images/stressburner-faviconlogo.png' | relative_url }}">
  <link rel="apple-touch-icon" href="{{ '/assets/images/stressburner-faviconlogo.png' | relative_url }}">
  <meta name="theme-color" content="#9A0C0C">
</head>
<body class="page-{{ page.title | downcase | replace: ' ', '-' }}">
  <header class="sb-header" id="sb-header-normal">
    <div class="container header-inner">
      <a class="brand" href="{{ '/' | relative_url }}" aria-label="{{ site.title }}">
        <span class="logo" aria-hidden="true">
          <img class="logo-icon" src="{{ '/assets/images/stress-burner-lotus.svg' | relative_url }}" alt="" />
        </span>
        <span class="sr-only">{{ site.title }}</span>
      </a>
      <button class="nav-toggle" aria-expanded="false" aria-controls="primary-nav-normal">☰</button>
      <nav id="primary-nav-normal" class="nav">
        {% for item in site.nav %}
          {% if item.external %}
            <a href="{{ item.external }}" class="nav-link" target="_blank" rel="noopener">{{ item.title }}</a>
          {% else %}
            <a href="{{ item.url | relative_url }}" class="nav-link{% if page.url == item.url %} active{% endif %}">{{ item.title }}</a>
          {% endif %}
        {% endfor %}
      </nav>
    </div>
  </header>

  <!-- Fixed clone header for scroll-up reveal -->
  <header class="sb-header sb-header--fixed" id="sb-header-fixed" aria-hidden="true">
    <div class="container header-inner">
      <a class="brand" href="{{ '/' | relative_url }}" aria-label="{{ site.title }}">
        <span class="logo" aria-hidden="true">
          <img class="logo-icon" src="{{ '/assets/images/stress-burner-lotus.svg' | relative_url }}" alt="" />
        </span>
        <span class="sr-only">{{ site.title }}</span>
      </a>
      <button class="nav-toggle" aria-expanded="false" aria-controls="primary-nav-fixed">☰</button>
      <nav id="primary-nav-fixed" class="nav">
        {% for item in site.nav %}
          {% if item.external %}
            <a href="{{ item.external }}" class="nav-link" target="_blank" rel="noopener">{{ item.title }}</a>
          {% else %}
            <a href="{{ item.url | relative_url }}" class="nav-link{% if page.url == item.url %} active{% endif %}">{{ item.title }}</a>
          {% endif %}
        {% endfor %}
      </nav>
    </div>
  </header>

  <main>
    {{ content }}
  </main>

  <footer class="sb-footer">
    <div class="container">
      <p>© {{ site.time | date: '%Y' }} {{ site.title }} · <a href="{{ '/contact/' | relative_url }}">Contact</a></p>
    </div>
  </footer>
  <script>
    (function(){
      // Wire up all nav toggles to their respective nav containers
      const navToggles = Array.from(document.querySelectorAll('.nav-toggle'));
      navToggles.forEach(btn => {
        const targetId = btn.getAttribute('aria-controls');
        const nav = targetId ? document.getElementById(targetId) : null;
        if (!nav) return;
        btn.addEventListener('click', () => {
          const open = btn.getAttribute('aria-expanded') === 'true';
          btn.setAttribute('aria-expanded', String(!open));
          nav.classList.toggle('open', !open);
          // Ensure fixed header remains visible when its menu opens
          const fixedHeader = document.getElementById('sb-header-fixed');
          if (fixedHeader && fixedHeader.contains(btn) && !open) {
            fixedHeader.classList.add('is-visible');
            fixedHeader.setAttribute('aria-hidden', 'false');
            const normalHeader = document.getElementById('sb-header-normal');
            if (normalHeader) normalHeader.classList.add('is-invisible');
          }
        });
      });

      // Progressive header blur/background on scroll (apply to both headers)
      const normalHeader = document.getElementById('sb-header-normal');
      const fixedHeader = document.getElementById('sb-header-fixed');
      if (normalHeader && fixedHeader) {
        let ticking = false;
  let lastY = window.scrollY || window.pageYOffset || 0;
  const DELTA_MIN = 4;
  const TOP_THRESH = 0; // swap back only at the true top
        const max = 180;
        const applyVars = (el, t) => {
          el.style.setProperty('--header-bg', (0.75 * t).toFixed(3));
          el.style.setProperty('--header-blur', (8 * t).toFixed(2) + 'px');
          el.style.setProperty('--header-border', (0.06 * t).toFixed(3));
          el.style.setProperty('--header-shadow', t.toFixed(3));
        };
        const update = () => {
          const y = window.scrollY || window.pageYOffset || 0;
          const t = Math.max(0, Math.min(1, y / max));
          applyVars(normalHeader, t);
          applyVars(fixedHeader, t);
          const dy = y - lastY;
          const fixedNavOpenBtn = fixedHeader.querySelector('.nav-toggle');
          const fixedNavOpen = !!(fixedNavOpenBtn && fixedNavOpenBtn.getAttribute('aria-expanded') === 'true');
          const H = normalHeader.offsetHeight || 64;
          const TOP_BUFFER = H + 12; // px beyond header height to prevent early fixed reveal

          if (y <= TOP_THRESH) {
            // At the very top: show normal header, hide fixed clone instantly (no animation)
            if (fixedHeader.classList.contains('is-visible')) {
              // Hard-disable transition for this swap to avoid any slide-out animation
              fixedHeader.classList.add('no-anim');
              fixedHeader.style.setProperty('transition', 'none', 'important');
              fixedHeader.classList.remove('is-visible');
              fixedHeader.setAttribute('aria-hidden', 'true');
              // Force reflow to apply style changes immediately
              void fixedHeader.getBoundingClientRect();
              // Restore transitions on next frame for future interactions
              requestAnimationFrame(() => {
                fixedHeader.style.removeProperty('transition');
                fixedHeader.classList.remove('no-anim');
              });
            } else {
              fixedHeader.classList.remove('is-visible');
              fixedHeader.setAttribute('aria-hidden', 'true');
            }
            normalHeader.classList.remove('is-invisible');
          } else if (dy < -DELTA_MIN || fixedNavOpen) {
            // Scrolling up (or fixed menu open): only reveal fixed clone after passing buffer depth
            if (fixedNavOpen || y > TOP_BUFFER) {
              fixedHeader.classList.add('is-visible');
              fixedHeader.setAttribute('aria-hidden', 'false');
              normalHeader.classList.add('is-invisible');
            } else {
              // Still within buffer near the top: keep using normal header without showing fixed
              fixedHeader.classList.remove('is-visible');
              fixedHeader.setAttribute('aria-hidden', 'true');
              normalHeader.classList.remove('is-invisible');
            }
          } else if (dy > DELTA_MIN) {
            // Scrolling down: hide fixed clone; normal remains invisible but off-screen naturally
            fixedHeader.classList.remove('is-visible');
            fixedHeader.setAttribute('aria-hidden', 'true');
            // Keep normal header invisible while mid-page to avoid double header near threshold
          }
          lastY = y;
          ticking = false;
        };
        update();
        window.addEventListener('scroll', () => {
          if (!ticking) { ticking = true; requestAnimationFrame(update); }
        }, { passive: true });
      }

      // Smooth pressed animation for buttons (adds/removes .is-pressed)
      try {
        const pressables = document.querySelectorAll('.btn');
        const add = (el) => el.classList.add('is-pressed');
        const remove = (el) => el.classList.remove('is-pressed');
        pressables.forEach(btn => {
          btn.addEventListener('pointerdown', () => add(btn));
          btn.addEventListener('pointerup', () => remove(btn));
          btn.addEventListener('pointerleave', () => remove(btn));
          btn.addEventListener('pointercancel', () => remove(btn));
          btn.addEventListener('blur', () => remove(btn));
          btn.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') add(btn); });
          btn.addEventListener('keyup', () => remove(btn));
        });
      } catch {}

      // Inject flowers SVG inline into hero so we can style stroke/fill via CSS (no edits to the SVG file itself)
      const heroContainer = document.querySelector('.hero .container');
      if (heroContainer) {
        // Ensure background layers exist for animation/parallax
        const ensureLayer = (cls) => {
          let el = heroContainer.querySelector(`.${cls}`);
          if (!el) {
            el = document.createElement('div');
            el.className = `bg-layer ${cls}`;
            heroContainer.insertBefore(el, heroContainer.firstChild);
          }
          return el;
        };
        const bg0 = ensureLayer('bg-0');
        const bg1 = ensureLayer('bg-1');

        // Parallax setup (outside fetch so it always runs)
        const heroSection = document.querySelector('.hero');
        const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        let flowers = null;
        let ticking2 = false;
  // Device tilt state (mobile additive parallax)
  let tiltY = 0;          // smoothed [-1, 1] (front-back)
  let tiltX = 0;          // smoothed [-1, 1] (left-right)
  let targetTiltY = 0;    // instantaneous [-1, 1]
  let targetTiltX = 0;    // instantaneous [-1, 1]
  let beta0 = null;       // baseline beta (pitch)
  let gamma0 = null;      // baseline gamma (roll)
  let tiltEnabled = false;

        const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
        const px = (n) => `${Math.round(n)}px`;
        const updateParallax = () => {
          if (!heroSection || prefersReduced) { ticking2 = false; return; }
          const rect = heroSection.getBoundingClientRect();
          const h = rect.height || 1;
          // Progress based on page scroll so it starts as soon as the user scrolls even a little
          const y = window.scrollY || window.pageYOffset || 0;
          const t = clamp(y / h, 0, 1);
          // Scale motion
          const isMobile = (window.innerWidth || 0) <= 900;
          const scale = isMobile ? 1.0 : 1.3;
          // Downward movement: flowers (least), foreground (more), background 0 (most)
          const mf = 60 * scale;    // flowers overlay (smallest)
          const m1 = 250 * scale;   // foreground (middle)
          const m0 = 340 * scale;   // far background (largest)
          // Smooth tilt easing for both axes
          tiltY += (targetTiltY - tiltY) * 0.12;
          tiltX += (targetTiltX - tiltX) * 0.12;
          // Convert tilt to additive px motion (mobile only)
          const tFactor = isMobile ? 1 : 0; // only enable on mobile widths
          // Subtler tilt amplitudes (reduced from prior values)
          const add0y = tFactor * (tiltY * 30); // was 50
          const add1y = tFactor * (tiltY * 18); // was 32
          const addFy = tFactor * (tiltY * 8);  // was 14
          const add0x = tFactor * (tiltX * 16); // was 30
          const add1x = tFactor * (tiltX * 11); // was 20
          const addFx = tFactor * (tiltX * 5);  // was 8
          if (bg0) { bg0.style.setProperty('--scroll-y', px((t * m0) + add0y)); bg0.style.setProperty('--bg-x', px(add0x)); }
          if (bg1) { bg1.style.setProperty('--scroll-y', px((t * m1) + add1y)); bg1.style.setProperty('--bg-x', px(add1x)); }
          if (flowers) { flowers.style.setProperty('--scroll-y', px((t * mf) + addFy)); flowers.style.setProperty('--scroll-x', px(addFx)); }
          ticking2 = false;
        };
        const onScroll = () => { if (!ticking2) { ticking2 = true; requestAnimationFrame(updateParallax); } };
        window.addEventListener('scroll', onScroll, { passive: true });
  window.addEventListener('resize', () => { requestAnimationFrame(updateParallax); }, { passive: true });
  window.addEventListener('orientationchange', () => { beta0 = null; gamma0 = null; }, { passive: true });
        updateParallax();

        // Device orientation activation (with iOS permission flow)
        const tryEnableTilt = async () => {
          if (tiltEnabled || prefersReduced) return;
          const isMobile = (window.innerWidth || 0) <= 900;
          if (!isMobile) return;
          try {
            if (typeof window.DeviceOrientationEvent !== 'undefined' && typeof window.DeviceOrientationEvent.requestPermission === 'function') {
              // iOS requires a user gesture
              const res = await window.DeviceOrientationEvent.requestPermission();
              if (res !== 'granted') return;
            }
            const onOrient = (e) => {
              // beta: front-back tilt (pitch), gamma: left-right tilt (roll)
              const beta = typeof e.beta === 'number' ? e.beta : 0;
              const gamma = typeof e.gamma === 'number' ? e.gamma : 0;
              // Capture baseline on first reading
              if (beta0 === null) beta0 = beta;
              if (gamma0 === null) gamma0 = gamma;
              const dBeta = beta - beta0;
              const dGamma = gamma - gamma0;
              // Normalize to [-1, 1] using +/-30° saturation for sensitivity
              targetTiltY = clamp(dBeta / 30, -1, 1);
              targetTiltX = clamp(dGamma / 30, -1, 1);
              if (!ticking2) { ticking2 = true; requestAnimationFrame(updateParallax); }
            };
            window.addEventListener('deviceorientation', onOrient, true);
            tiltEnabled = true;
          } catch { /* ignore permission errors */ }
        };
        // For Android and browsers that don't need explicit permission, try enabling immediately
        if (typeof window.DeviceOrientationEvent !== 'undefined' && typeof window.DeviceOrientationEvent.requestPermission !== 'function') {
          tryEnableTilt();
        }
        // Fallback: enable tilt after first user interaction (for iOS)
        const onceActivate = () => { tryEnableTilt(); window.removeEventListener('touchend', onceActivate); window.removeEventListener('click', onceActivate); };
        window.addEventListener('touchend', onceActivate, { passive: true, once: true });
        window.addEventListener('click', onceActivate, { once: true });

        // Fetch and inline the flowers SVG (so CSS can style it)
        const svgUrl = '{{ "/assets/images/hero-background-layer-flowers.svg" | relative_url }}';
        try {
          fetch(svgUrl, { cache: 'force-cache' })
            .then(r => r.ok ? r.text() : Promise.reject(r.status))
            .then(svgText => {
              const wrap = document.createElement('div');
              wrap.className = 'flowers-layer';
              wrap.innerHTML = svgText;
              // Normalize dimensions and aspect ratio handling so CSS centering works consistently
              const svgEl = wrap.querySelector('svg');
              if (svgEl) {
                svgEl.removeAttribute('width');
                svgEl.removeAttribute('height');
                // Use 'slice' to mimic CSS background-size: cover behavior within the hero container
                svgEl.setAttribute('preserveAspectRatio', 'xMidYMid slice');
              }
              heroContainer.appendChild(wrap);
              flowers = wrap;
              // Apply an initial parallax position now that flowers exist
              requestAnimationFrame(updateParallax);
            })
            .catch(() => { /* no-op if SVG fails to load */ });
        } catch { /* ignore */ }
      }
    })();
  </script>
</body>
</html>