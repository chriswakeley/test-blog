<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{% if page.title %}{{ page.title }} · {% endif %}{{ site.title }}</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="{{ '/assets/css/tailwind.css' | relative_url }}">
  <link rel="stylesheet" href="{{ '/assets/css/main.css' | relative_url }}">
  {% seo %}
  <link rel="icon" type="image/png" href="{{ '/assets/images/stressburner-faviconlogo.png' | relative_url }}">
  <link rel="apple-touch-icon" href="{{ '/assets/images/stressburner-faviconlogo.png' | relative_url }}">
  <meta name="theme-color" content="#9A0C0C">
</head>
<body class="page-{{ page.title | downcase | replace: ' ', '-' }}">
  <header class="sb-header" id="sb-header-normal">
    <div class="container header-inner">
      <a class="brand" href="{{ '/' | relative_url }}" aria-label="{{ site.title }}">
        <span class="logo" aria-hidden="true">
          <img class="logo-icon" src="{{ '/assets/images/stress-burner-lotus.svg' | relative_url }}" alt="" />
        </span>
        <span class="sr-only">{{ site.title }}</span>
      </a>
      <button class="nav-toggle" aria-expanded="false" aria-controls="primary-nav-normal">☰</button>
      <nav id="primary-nav-normal" class="nav">
        {% for item in site.nav %}
          {% if item.external %}
            <a href="{{ item.external }}" class="nav-link" target="_blank" rel="noopener">{{ item.title }}</a>
          {% else %}
            <a href="{{ item.url | relative_url }}" class="nav-link{% if page.url == item.url %} active{% endif %}">{{ item.title }}</a>
          {% endif %}
        {% endfor %}
      </nav>
    </div>
  </header>

  <!-- Fixed clone header for scroll-up reveal -->
  <header class="sb-header sb-header--fixed" id="sb-header-fixed" aria-hidden="true">
    <div class="container header-inner">
      <a class="brand" href="{{ '/' | relative_url }}" aria-label="{{ site.title }}">
        <span class="logo" aria-hidden="true">
          <img class="logo-icon" src="{{ '/assets/images/stress-burner-lotus.svg' | relative_url }}" alt="" />
        </span>
        <span class="sr-only">{{ site.title }}</span>
      </a>
      <button class="nav-toggle" aria-expanded="false" aria-controls="primary-nav-fixed">☰</button>
      <nav id="primary-nav-fixed" class="nav">
        {% for item in site.nav %}
          {% if item.external %}
            <a href="{{ item.external }}" class="nav-link" target="_blank" rel="noopener">{{ item.title }}</a>
          {% else %}
            <a href="{{ item.url | relative_url }}" class="nav-link{% if page.url == item.url %} active{% endif %}">{{ item.title }}</a>
          {% endif %}
        {% endfor %}
      </nav>
    </div>
  </header>

  <main>
    {{ content }}
  </main>

  <footer class="sb-footer">
    <div class="container">
      <p>© {{ site.time | date: '%Y' }} {{ site.title }} · <a href="{{ '/contact/' | relative_url }}">Contact</a></p>
    </div>
  </footer>
  <script>
    (function(){
      // Wire up all nav toggles to their respective nav containers
      const navToggles = Array.from(document.querySelectorAll('.nav-toggle'));
      navToggles.forEach(btn => {
        const targetId = btn.getAttribute('aria-controls');
        const nav = targetId ? document.getElementById(targetId) : null;
        if (!nav) return;
        btn.addEventListener('click', () => {
          const open = btn.getAttribute('aria-expanded') === 'true';
          btn.setAttribute('aria-expanded', String(!open));
          nav.classList.toggle('open', !open);
          // Ensure fixed header remains visible when its menu opens
          const fixedHeader = document.getElementById('sb-header-fixed');
          if (fixedHeader && fixedHeader.contains(btn) && !open) {
            fixedHeader.classList.add('is-visible');
            fixedHeader.setAttribute('aria-hidden', 'false');
            const normalHeader = document.getElementById('sb-header-normal');
            if (normalHeader) normalHeader.classList.add('is-invisible');
          }
        });
      });

      // Progressive header blur/background on scroll (apply to both headers)
      const normalHeader = document.getElementById('sb-header-normal');
      const fixedHeader = document.getElementById('sb-header-fixed');
      if (normalHeader && fixedHeader) {
        let ticking = false;
  let lastY = window.scrollY || window.pageYOffset || 0;
  const DELTA_MIN = 4;
  const TOP_THRESH = 0; // swap back only at the true top
        const max = 180;
        let animatingIn = false;
        let pendingTopSwap = false;
        // Helper: instant-hide the fixed header (no animation)
        const instantHideFixed = () => {
          fixedHeader.classList.add('no-anim');
          fixedHeader.style.setProperty('transition', 'none', 'important');
          fixedHeader.classList.remove('is-visible');
          fixedHeader.setAttribute('aria-hidden', 'true');
          // Force reflow so styles apply immediately
          void fixedHeader.getBoundingClientRect();
          requestAnimationFrame(() => {
            fixedHeader.style.removeProperty('transition');
            fixedHeader.classList.remove('no-anim');
          });
        };
        // Gently fade out fixed header's island shadows/background before swapping to normal at top
        const fadeOutHeaderThenSwap = () => {
          // Keep normal hidden during fade to avoid double header
          normalHeader.classList.add('is-invisible');
          // Trigger fade on the fixed header island
          fixedHeader.classList.add('is-fading');
          const headerInner = fixedHeader.querySelector('.header-inner');
          let done = false;
          const finish = () => {
            if (done) return; done = true;
            fixedHeader.classList.remove('is-fading');
            instantHideFixed();
            normalHeader.classList.remove('is-invisible');
          };
          const onEnd = (e) => {
            if (!headerInner || e.target !== headerInner) return;
            if (e.propertyName !== 'background-color' && e.propertyName !== 'backdrop-filter' && e.propertyName !== '-webkit-backdrop-filter') return;
            headerInner.removeEventListener('transitionend', onEnd);
            finish();
          };
          if (headerInner) headerInner.addEventListener('transitionend', onEnd);
          // Fallback timeout in case transitionend is missed
          setTimeout(finish, 300);
        };
        // Listen for the end of the transform transition to honor delayed top swap
        fixedHeader.addEventListener('transitionend', (e) => {
          if (e.propertyName !== 'transform') return;
          if (animatingIn) {
            animatingIn = false;
            fixedHeader.classList.remove('is-top-animating');
            if (pendingTopSwap) {
              const yNow = window.scrollY || window.pageYOffset || 0;
              if (yNow <= TOP_THRESH) {
                fadeOutHeaderThenSwap();
              }
              pendingTopSwap = false;
            }
          }
        });
        const applyVars = (el, t) => {
          el.style.setProperty('--header-bg', (0.75 * t).toFixed(3));
          el.style.setProperty('--header-blur', (8 * t).toFixed(2) + 'px');
          el.style.setProperty('--header-border', (0.06 * t).toFixed(3));
          el.style.setProperty('--header-shadow', t.toFixed(3));
        };
        const update = () => {
          const y = window.scrollY || window.pageYOffset || 0;
          const t = Math.max(0, Math.min(1, y / max));
          // Keep the in-flow header visually neutral (no shadow/blur/background)
          normalHeader.style.setProperty('--header-bg', '0');
          normalHeader.style.setProperty('--header-blur', '0px');
          normalHeader.style.setProperty('--header-border', '0');
          normalHeader.style.setProperty('--header-shadow', '0');
          // Animate effects only on the fixed clone
          applyVars(fixedHeader, t);
          const dy = y - lastY;
          const fixedNavOpenBtn = fixedHeader.querySelector('.nav-toggle');
          const fixedNavOpen = !!(fixedNavOpenBtn && fixedNavOpenBtn.getAttribute('aria-expanded') === 'true');
          const H = normalHeader.offsetHeight || 64;
          const TOP_BUFFER = H + 256; // testing: larger buffer to verify clone suppression

          if (y <= TOP_THRESH) {
            // At the very top
            if (fixedHeader.classList.contains('is-visible')) {
              if (animatingIn) {
                // Defer the instant swap until the slide-in completes; keep normal hidden to avoid double headers
                pendingTopSwap = true;
                fixedHeader.classList.add('is-top-animating');
                normalHeader.classList.add('is-invisible');
              } else {
                // Fixed is visible but not animating: fade shadows out, then swap
                fadeOutHeaderThenSwap();
              }
            } else {
              // Fixed is not visible, show normal
              fixedHeader.classList.remove('is-visible');
              fixedHeader.setAttribute('aria-hidden', 'true');
              normalHeader.classList.remove('is-invisible');
            }
          } else if (dy < -DELTA_MIN || fixedNavOpen) {
            // Scrolling up (or fixed menu open): only reveal fixed clone after passing buffer depth
            if (fixedNavOpen || y > TOP_BUFFER) {
              // Past the buffer: reveal fixed clone and hide normal visually
              if (!fixedHeader.classList.contains('is-visible')) {
                animatingIn = true;
              }
              fixedHeader.classList.add('is-visible');
              fixedHeader.setAttribute('aria-hidden', 'false');
              normalHeader.classList.add('is-invisible');
              // If at the true top during animation, ensure top-animating state is set
              if (y <= TOP_THRESH) {
                fixedHeader.classList.add('is-top-animating');
              } else {
                fixedHeader.classList.remove('is-top-animating');
              }
            } else {
              // Inside buffer: do not trigger instant swap; keep current state
              if (!fixedHeader.classList.contains('is-visible')) {
                // Keep fixed hidden and show normal header
                fixedHeader.classList.remove('is-visible');
                fixedHeader.setAttribute('aria-hidden', 'true');
                normalHeader.classList.remove('is-invisible');
              } else {
                // Fixed is already visible (coming from deeper): keep it visible until true top
                // No class changes here
              }
            }
          } else if (dy > DELTA_MIN) {
            // Scrolling down: hide fixed clone (animated)
            animatingIn = false; // cancel any pending 'in' state
            pendingTopSwap = false; // cancel delayed top swap on downward scroll
            fixedHeader.classList.remove('is-visible');
            fixedHeader.setAttribute('aria-hidden', 'true');
            fixedHeader.classList.remove('is-top-animating');
            if (y <= TOP_BUFFER) {
              // Inside buffer: show normal header (no instant swap unless true top branch handles it)
              normalHeader.classList.remove('is-invisible');
            }
            // Keep normal header invisible while mid-page to avoid double header near threshold
          }
          lastY = y;
          ticking = false;
        };
        update();
        window.addEventListener('scroll', () => {
          if (!ticking) { ticking = true; requestAnimationFrame(update); }
        }, { passive: true });
      }

      // Smooth pressed animation for buttons (adds/removes .is-pressed)
      try {
        const pressables = document.querySelectorAll('.btn');
        const add = (el) => el.classList.add('is-pressed');
        const remove = (el) => el.classList.remove('is-pressed');
        pressables.forEach(btn => {
          btn.addEventListener('pointerdown', () => add(btn));
          btn.addEventListener('pointerup', () => remove(btn));
          btn.addEventListener('pointerleave', () => remove(btn));
          btn.addEventListener('pointercancel', () => remove(btn));
          btn.addEventListener('blur', () => remove(btn));
          btn.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') add(btn); });
          btn.addEventListener('keyup', () => remove(btn));
        });
      } catch {}

      // Inject flowers SVG inline into hero so we can style stroke/fill via CSS (no edits to the SVG file itself)
      const heroContainer = document.querySelector('.hero .container');
      if (heroContainer) {
        // Ensure background layers exist for animation/parallax
        const ensureLayer = (cls) => {
          let el = heroContainer.querySelector(`.${cls}`);
          if (!el) {
            el = document.createElement('div');
            el.className = `bg-layer ${cls}`;
            heroContainer.insertBefore(el, heroContainer.firstChild);
          }
          return el;
        };
        const bg0 = ensureLayer('bg-0');
        const bg1 = ensureLayer('bg-1');

        // Parallax setup (outside fetch so it always runs)
        const heroSection = document.querySelector('.hero');
        const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        let flowers = null;
        let ticking2 = false;
  // Device tilt state (mobile additive parallax)
  let tiltY = 0;          // smoothed [-1, 1] (front-back)
  let tiltX = 0;          // smoothed [-1, 1] (left-right)
  let targetTiltY = 0;    // instantaneous [-1, 1]
  let targetTiltX = 0;    // instantaneous [-1, 1]
  let beta0 = null;       // baseline beta (pitch)
  let gamma0 = null;      // baseline gamma (roll)
  let tiltEnabled = false;

        const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const px = (n) => `${Number(n).toFixed(2)}px`;
        const updateParallax = () => {
          if (!heroSection || prefersReduced) { ticking2 = false; return; }
          const rect = heroSection.getBoundingClientRect();
          const h = rect.height || 1;
          // Progress based on page scroll so it starts as soon as the user scrolls even a little
          const y = window.scrollY || window.pageYOffset || 0;
          const t = clamp(y / h, 0, 1);
          // Scale motion
          const isMobile = (window.innerWidth || 0) <= 900;
          const scale = isMobile ? 1.0 : 1.3;
          const mobileOffset = isMobile ? 0 : 0;
          // Downward movement: flowers (least), foreground (more), background 0 (most)
          const mf = 60 * scale;    // flowers overlay (smallest)
          const m1 = 250 * scale;   // foreground (middle)
          const m0 = 340 * scale;   // far background (largest)
          // Smooth tilt easing for both axes
          tiltY += (targetTiltY - tiltY) * 0.12;
          tiltX += (targetTiltX - tiltX) * 0.12;
          // Convert tilt to additive px motion (mobile only)
          const tFactor = isMobile ? 1 : 0; // only enable on mobile widths
          // Subtler tilt amplitudes (reduced from prior values)
          const add0y = tFactor * (tiltY * 30); // was 50
          const add1y = tFactor * (tiltY * 18); // was 32
          const addFy = tFactor * (tiltY * 8);  // was 14
          const add0x = tFactor * (tiltX * 16); // was 30
          const add1x = tFactor * (tiltX * 11); // was 20
          const addFx = tFactor * (tiltX * 5);  // was 8
          if (bg0) { bg0.style.setProperty('--scroll-y', px((t * m0) + add0y + mobileOffset)); bg0.style.setProperty('--scroll-x', px(add0x)); }
          if (bg1) { bg1.style.setProperty('--scroll-y', px((t * m1) + add1y + mobileOffset)); bg1.style.setProperty('--scroll-x', px(add1x)); }
          if (flowers) { flowers.style.setProperty('--scroll-y', px((t * mf) + addFy + mobileOffset)); flowers.style.setProperty('--scroll-x', px(addFx)); }
          ticking2 = false;
        };
        const onScroll = () => { if (!ticking2) { ticking2 = true; requestAnimationFrame(updateParallax); } };
        window.addEventListener('scroll', onScroll, { passive: true });
  window.addEventListener('resize', () => { requestAnimationFrame(updateParallax); }, { passive: true });
  window.addEventListener('orientationchange', () => { beta0 = null; gamma0 = null; }, { passive: true });
        updateParallax();

        // Device orientation activation (with iOS permission flow)
        const tryEnableTilt = async () => {
          if (tiltEnabled || prefersReduced) return;
          const isMobile = (window.innerWidth || 0) <= 900;
          if (!isMobile) return;
          try {
            if (typeof window.DeviceOrientationEvent !== 'undefined' && typeof window.DeviceOrientationEvent.requestPermission === 'function') {
              // iOS requires a user gesture
              const res = await window.DeviceOrientationEvent.requestPermission();
              if (res !== 'granted') return;
            }
            const onOrient = (e) => {
              // beta: front-back tilt (pitch), gamma: left-right tilt (roll)
              const beta = typeof e.beta === 'number' ? e.beta : 0;
              const gamma = typeof e.gamma === 'number' ? e.gamma : 0;
              // Capture baseline on first reading
              if (beta0 === null) beta0 = beta;
              if (gamma0 === null) gamma0 = gamma;
              const dBeta = beta - beta0;
              const dGamma = gamma - gamma0;
              // Normalize to [-1, 1] using +/-30° saturation for sensitivity
              targetTiltY = clamp(dBeta / 30, -1, 1);
              targetTiltX = clamp(dGamma / 30, -1, 1);
              if (!ticking2) { ticking2 = true; requestAnimationFrame(updateParallax); }
            };
            window.addEventListener('deviceorientation', onOrient, true);
            tiltEnabled = true;
          } catch { /* ignore permission errors */ }
        };
        // For Android and browsers that don't need explicit permission, try enabling immediately
        if (typeof window.DeviceOrientationEvent !== 'undefined' && typeof window.DeviceOrientationEvent.requestPermission !== 'function') {
          tryEnableTilt();
        }
        // Fallback: enable tilt after first user interaction (for iOS)
        const onceActivate = () => { tryEnableTilt(); window.removeEventListener('touchend', onceActivate); window.removeEventListener('click', onceActivate); };
        window.addEventListener('touchend', onceActivate, { passive: true, once: true });
        window.addEventListener('click', onceActivate, { once: true });

        // Fetch and inline the flowers SVG (so CSS can style it)
        const svgUrl = '{{ "/assets/images/hero-background-layer-flowers.svg" | relative_url }}';
        try {
          fetch(svgUrl, { cache: 'force-cache' })
            .then(r => r.ok ? r.text() : Promise.reject(r.status))
            .then(svgText => {
              const wrap = document.createElement('div');
              wrap.className = 'flowers-layer';
              wrap.innerHTML = svgText;
              // Normalize dimensions and aspect ratio handling so CSS centering works consistently
              const svgEl = wrap.querySelector('svg');
              if (svgEl) {
                svgEl.removeAttribute('width');
                svgEl.removeAttribute('height');
                // Use 'slice' to mimic CSS background-size: cover behavior within the hero container
                svgEl.setAttribute('preserveAspectRatio', 'xMidYMid slice');
              }
              heroContainer.appendChild(wrap);
              flowers = wrap;
              // Apply an initial parallax position now that flowers exist
              requestAnimationFrame(updateParallax);
            })
            .catch(() => { /* no-op if SVG fails to load */ });
        } catch { /* ignore */ }
      }

      // Initialize layered parallax stacks (e.g., stones on course page)
      (function initParallaxStacks(){
        const stacks = Array.from(document.querySelectorAll('.parallax-stack'));
        if (!stacks.length) return;
        const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const px = (n) => `${Number(n).toFixed(2)}px`;
        let ticking = false;
        // Shared device tilt state
        let tiltY = 0, tiltX = 0, targetTiltY = 0, targetTiltX = 0;
        let beta0 = null, gamma0 = null;
        let tiltEnabled = false;
        // Stable viewport base to avoid iOS toolbar-induced innerHeight jitter
        let vhBase = window.innerHeight || 1;
        let vwBase = window.innerWidth || 1;
        const updateViewportBase = () => {
          const h = window.innerHeight || 1;
          const w = window.innerWidth || 1;
          // Only update when there is a significant change (orientation swap etc.)
          if (Math.abs(h - vhBase) > 120 || Math.abs(w - vwBase) > 80) {
            vhBase = h; vwBase = w;
          }
        };

        const updateStack = (stack) => {
          if (prefersReduced || !stack.isConnected) return;
          // Calculate progress from the stack's absolute position using a stable viewport base
          const y = window.scrollY || window.pageYOffset || 0;
          const rect = stack.getBoundingClientRect();
          const stackTopAbs = y + rect.top;
          const travel = (vhBase + (rect.height || 0)) || 1; // element traverses viewport base + its own height
          // Top reaching bottom of stable viewport => 0; bottom crossing top => 1
          const t = clamp((y + vhBase - stackTopAbs) / travel, 0, 1);
          const isMobile = (window.innerWidth || 0) <= 900;
          const scale = isMobile ? 0.7 : 1.0;
          const mobileOffset = isMobile ? 24 : 0;
          // Match hero depths (largest for far background)
          const mBg = 300 * scale;
          const mMid = 100 * scale;
          const mFore = -30 * scale;
          // Smooth tilt easing (match hero amplitudes)
          tiltY += (targetTiltY - tiltY) * 0.12;
          tiltX += (targetTiltX - tiltX) * 0.12;
          const tFactor = isMobile ? 1 : 0; // only enable tilt on mobile widths
          const addBgY = tFactor * (tiltY * 30) - 200 + mobileOffset/2;
          const addMidY = tFactor * (tiltY * 18) - 80 + mobileOffset/0.6;
          const addForeY = tFactor * (tiltY * -8) + 25 - mobileOffset/0.7;
          const addBgX = tFactor * (tiltX * 10);
          const addMidX = tFactor * (tiltX * 6);
          const addForeX = tFactor * (tiltX * -3);

          const bg = stack.querySelector('.stones-bg, .parallax-layer.bg');
          const mid = stack.querySelector('.stones-mid, .parallax-layer.mid');
          const fore = stack.querySelector('.stones-fore, .parallax-layer.fore');
          if (bg) { bg.style.setProperty('--scroll-y', px((t * mBg) + addBgY + mobileOffset)); bg.style.setProperty('--scroll-x', px(addBgX)); }
          if (mid) { mid.style.setProperty('--scroll-y', px((t * mMid) + addMidY + mobileOffset)); mid.style.setProperty('--scroll-x', px(addMidX)); }
          if (fore) { fore.style.setProperty('--scroll-y', px((t * mFore) + addForeY + mobileOffset)); fore.style.setProperty('--scroll-x', px(addForeX)); }
        };

        const onScroll = () => {
          if (ticking) return; ticking = true;
          requestAnimationFrame(() => {
            stacks.forEach(updateStack);
            ticking = false;
          });
        };
        window.addEventListener('scroll', onScroll, { passive: true });
  window.addEventListener('resize', () => { updateViewportBase(); requestAnimationFrame(onScroll); }, { passive: true });
  window.addEventListener('orientationchange', () => { vhBase = window.innerHeight || vhBase; vwBase = window.innerWidth || vwBase; requestAnimationFrame(onScroll); }, { passive: true });
        onScroll();

        // Device orientation activation
        const tryEnableTilt = async () => {
          if (tiltEnabled || prefersReduced) return;
          const isMobile = (window.innerWidth || 0) <= 900;
          if (!isMobile) return;
          try {
            if (typeof window.DeviceOrientationEvent !== 'undefined' && typeof window.DeviceOrientationEvent.requestPermission === 'function') {
              const res = await window.DeviceOrientationEvent.requestPermission();
              if (res !== 'granted') return;
            }
            const onOrient = (e) => {
              const beta = typeof e.beta === 'number' ? e.beta : 0;
              const gamma = typeof e.gamma === 'number' ? e.gamma : 0;
              if (beta0 === null) beta0 = beta;
              if (gamma0 === null) gamma0 = gamma;
              const dBeta = beta - beta0;
              const dGamma = gamma - gamma0;
              targetTiltY = clamp(dBeta / 30, -1, 1);
              targetTiltX = clamp(dGamma / 30, -1, 1);
              onScroll();
            };
            window.addEventListener('deviceorientation', onOrient, true);
            tiltEnabled = true;
          } catch {}
        };
        if (typeof window.DeviceOrientationEvent !== 'undefined' && typeof window.DeviceOrientationEvent.requestPermission !== 'function') {
          tryEnableTilt();
        }
        const onceActivate = () => { tryEnableTilt(); window.removeEventListener('touchend', onceActivate); window.removeEventListener('click', onceActivate); };
        window.addEventListener('touchend', onceActivate, { passive: true, once: true });
        window.addEventListener('click', onceActivate, { once: true });
      })();
    })();
  </script>
</body>
</html>